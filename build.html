<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ROS2 Robot Visualization</title>
  <script src="https://cdn.rawgit.com/RobotWebTools/roslibjs/0.20.0/build/roslib.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      color: #fff;
      overflow: hidden;
    }
    
    .container {
      display: flex;
      flex-direction: column;
      height: 100vh;
    }
    
    header {
      text-align: center;
      padding: 15px;
      background: rgba(0, 0, 0, 0.3);
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    h1 {
      margin: 0;
      font-size: 2.2rem;
      background: linear-gradient(90deg, #4e54c8, #8f94fb);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }
    
    .subtitle {
      font-size: 1rem;
      opacity: 0.8;
      margin-top: 5px;
    }
    
    .content {
      display: flex;
      flex: 1;
    }
    
    #visualization {
      flex: 1;
      position: relative;
    }
    
    .controls {
      width: 300px;
      padding: 20px;
      background: rgba(0, 0, 0, 0.2);
      border-left: 1px solid rgba(255, 255, 255, 0.1);
      display: flex;
      flex-direction: column;
      gap: 20px;
      overflow-y: auto;
    }
    
    .control-group {
      background: rgba(0, 0, 0, 0.3);
      padding: 15px;
      border-radius: 10px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }
    
    h2 {
      margin-top: 0;
      font-size: 1.3rem;
      color: #8f94fb;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      padding-bottom: 8px;
    }
    
    .button-group {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    
    button {
      background: linear-gradient(135deg, #4e54c8 0%, #8f94fb 100%);
      border: none;
      color: white;
      padding: 10px 15px;
      border-radius: 5px;
      cursor: pointer;
      transition: all 0.3s;
      flex: 1;
      min-width: 80px;
    }
    
    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }
    
    .teleop-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      grid-template-rows: repeat(3, 1fr);
      gap: 5px;
      margin: 10px 0;
    }
    
    .teleop-btn {
      aspect-ratio: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.5rem;
      padding: 0;
    }
    
    .slider-container {
      margin: 15px 0;
    }
    
    label {
      display: block;
      margin-bottom: 5px;
      font-weight: 500;
    }
    
    input[type="range"] {
      width: 100%;
      height: 5px;
      -webkit-appearance: none;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 5px;
      outline: none;
    }
    
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #8f94fb;
      cursor: pointer;
    }
    
    .status {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-top: 10px;
    }
    
    .status-indicator {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: #4caf50;
    }
    
    .status.off .status-indicator {
      background: #f44336;
    }
    
    footer {
      text-align: center;
      padding: 10px;
      font-size: 0.9rem;
      opacity: 0.7;
      background: rgba(0, 0, 0, 0.3);
      border-top: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    #rosStatus {
      position: fixed;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px;
      border-radius: 5px;
      z-index: 100;
    }
    
    .toggle {
      position: relative;
      display: inline-block;
      width: 60px;
      height: 30px;
    }
    
    .toggle input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    
    .toggle-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #333;
      transition: .4s;
      border-radius: 34px;
    }
    
    .toggle-slider:before {
      position: absolute;
      content: "";
      height: 22px;
      width: 22px;
      left: 4px;
      bottom: 4px;
      background-color: white;
      transition: .4s;
      border-radius: 50%;
    }
    
    input:checked + .toggle-slider {
      background: linear-gradient(135deg, #4e54c8 0%, #8f94fb 100%);
    }
    
    input:checked + .toggle-slider:before {
      transform: translateX(30px);
    }
    
    .light-control {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin: 10px 0;
    }
    
    .map-info {
      display: flex;
      flex-direction: column;
      gap: 5px;
      margin-top: 10px;
    }
    
    .map-info span {
      font-size: 0.9rem;
    }
  </style>
</head>
<body>

    
    <div class="content">
      <div id="visualization"></div>
      
      <div class="controls">
        <div class="control-group">
          <h2>Robot Movement</h2>
          <div class="teleop-grid">
            <button class="teleop-btn" onclick="move(1,1)">↖</button>
            <button class="teleop-btn" onclick="move(1,0)">↑</button>
            <button class="teleop-btn" onclick="move(1,-1)">↗</button>
            <button class="teleop-btn" onclick="move(0,1)">←</button>
            <button class="teleop-btn" onclick="move(0,0)">⏹</button>
            <button class="teleop-btn" onclick="move(0,-1)">→</button>
            <button class="teleop-btn" onclick="move(-1,1)">↙</button>
            <button class="teleop-btn" onclick="move(-1,0)">↓</button>
            <button class="teleop-btn" onclick="move(-1,-1)">↘</button>
          </div>
          <div class="slider-container">
            <label for="linSpeed">Linear Speed: <span id="linSpeedValue">0.3</span> m/s</label>
            <input type="range" id="linSpeed" min="0" max="1" step="0.1" value="0.3" oninput="document.getElementById('linSpeedValue').textContent = this.value">
          </div>
          <div class="slider-container">
            <label for="angSpeed">Angular Speed: <span id="angSpeedValue">1.0</span> rad/s</label>
            <input type="range" id="angSpeed" min="0" max="2" step="0.1" value="1.0" oninput="document.getElementById('angSpeedValue').textContent = this.value">
          </div>
        </div>
        
        <div class="control-group">
          <h2>Light Controls</h2>
          <div class="light-control">
            <span>Front Lights (White):</span>
            <label class="toggle">
              <input type="checkbox" id="frontLights" checked>
              <span class="toggle-slider"></span>
            </label>
          </div>
          <div class="light-control">
            <span>Rear Lights (Red):</span>
            <label class="toggle">
              <input type="checkbox" id="rearLights" checked>
              <span class="toggle-slider"></span>
            </label>
          </div>
        </div>
        
        <div class="control-group">
          <h2>Map Information</h2>
          <div class="map-info">
            <span id="mapDimensions">Dimensions: Not loaded</span>
            <span id="mapResolution">Resolution: Not loaded</span>
            <span id="mapLastUpdate">Last Update: Never</span>
          </div>
          <div class="button-group" style="margin-top: 10px;">
            <button id="toggleMap">Show Map</button>
            <button id="clearMap">Clear Map</button>
          </div>
        </div>
        
        <div class="control-group">
          <h2>Connection Status</h2>
          <div class="status">
            <div class="status-indicator" id="rosStatusIndicator"></div>
            <span id="rosStatusText">Connecting to ROS...</span>
          </div>
        </div>
      </div>
    </div>
    
    <footer>
      <p>ROS2 Robot Visualization with Three.js | WebGL Powered</p>
    </footer>
  </div>

  <script>
    let scene, camera, renderer, controls;
    let ros;
    let cmdVelTopic;
    let robotMesh;
    let robotGroup;
    let frontLightEmission1, frontLightEmission2;
    let rearLightEmission1, rearLightEmission2;
    let laserPointsMesh;
    
    // Map variables
    let mapTexture, mapMaterial, mapPlane, mapCanvas, mapCtx;
    let mapOrigin = {x:0, y:0};
    let mapResolution = 0.05;
    let showMap = false;
    
    let currentRobotPose = { 
      position: { x: 0, y: 0, z: 0 },
      orientation: { x: 0, y: 0, z: 0, w: 1 },
      yaw: 0
    };

    // Initialize the application
    initThree();
    connectROS();
    setupEventListeners();

    function initThree(){
      // Create scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x1a1a2e);
      
      // Setup camera
      camera = new THREE.PerspectiveCamera(60, (window.innerWidth - 300) / window.innerHeight, 0.1, 2000);
      camera.position.set(5, 8, 5);
      camera.lookAt(0, 0, 0);

      renderer = new THREE.WebGLRenderer({antialias:true});
      renderer.setSize(window.innerWidth - 300, window.innerHeight);
      renderer.shadowMap.enabled = true;
      document.getElementById('visualization').appendChild(renderer.domElement);

      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;

      // Add lighting
      scene.add(new THREE.AmbientLight(0x404040));
      
      let directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(10, 20, 10);
      directionalLight.castShadow = true;
      directionalLight.shadow.mapSize.width = 1024;
      directionalLight.shadow.mapSize.height = 1024;
      scene.add(directionalLight);

      // Create ground plane
      const groundGeometry = new THREE.PlaneGeometry(20, 20);
      const groundMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x16213e,
        roughness: 0.8,
        metalness: 0.2
      });
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      scene.add(ground);

      // Add grid helper
      const gridHelper = new THREE.GridHelper(20, 20, 0xffffff, 0xffffff);
      gridHelper.material.opacity = 0.2;
      gridHelper.material.transparent = true;
      scene.add(gridHelper);

      // Add coordinate axes for reference (X: red, Y: green, Z: blue)
      const axesHelper = new THREE.AxesHelper(2);
      scene.add(axesHelper);

      // Create the robot group // <<<<<   ALternative for URDF       <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      robotGroup = new THREE.Group();
      scene.add(robotGroup);

      // Create the robot body (silver box)
      const robotGeometry = new THREE.BoxGeometry(0.7, 0.21, 0.44);
      const robotMaterial = new THREE.MeshPhongMaterial({color:0xC0C0C0});
      robotMesh = new THREE.Mesh(robotGeometry, robotMaterial);
      robotMesh.position.set(0, 0.125, 0);
      robotMesh.castShadow = true;
      robotGroup.add(robotMesh);

      // Add front lights (white) - two lights at front
      const frontLightGeometry = new THREE.SphereGeometry(0.04, 16, 16);
      const frontLightMaterial = new THREE.MeshBasicMaterial({
        color: 0x87CEEB, // Light blue hex code
        transparent: true, // This is REQUIRED for opacity to work
        opacity: 0.5      // Adjust this value between 0.0 (invisible) and 1.0 (solid)
      });
      
      // Left front light
      const frontLightLeft = new THREE.Mesh(frontLightGeometry, frontLightMaterial);
      frontLightLeft.position.set(0.35, 0.125, 0.15);
      robotGroup.add(frontLightLeft);
      
      // Right front light
      const frontLightRight = new THREE.Mesh(frontLightGeometry, frontLightMaterial);
      frontLightRight.position.set(0.35, 0.125, -0.15);
      robotGroup.add(frontLightRight);
      
      // Add front light emission
      frontLightEmission1 = new THREE.PointLight(0xFFFFFF, 1, 2);
      frontLightEmission1.position.set(0.41, 0.125, 0.15);
      robotGroup.add(frontLightEmission1);
      
      frontLightEmission2 = new THREE.PointLight(0xFFFFFF, 1, 2);
      frontLightEmission2.position.set(0.41, 0.125, -0.15);
      robotGroup.add(frontLightEmission2);

      // Add rear lights (red) - two lights at rear
      const rearLightGeometry = new THREE.SphereGeometry(0.04, 16, 16);
      const rearLightMaterial = new THREE.MeshBasicMaterial({color: 0xFF0000});
      
      // Left rear light
      const rearLightLeft = new THREE.Mesh(rearLightGeometry, rearLightMaterial);
      rearLightLeft.position.set(-0.35, 0.125, 0.15);
      robotGroup.add(rearLightLeft);
      
      // Right rear light
      const rearLightRight = new THREE.Mesh(rearLightGeometry, rearLightMaterial);
      rearLightRight.position.set(-0.35, 0.125, -0.15);
      robotGroup.add(rearLightRight);
      
      // Add rear light emission
      rearLightEmission1 = new THREE.PointLight(0xFF0000, 1, 2);
      rearLightEmission1.position.set(-0.40, 0.125, 0.15);
      robotGroup.add(rearLightEmission1);
      
      rearLightEmission2 = new THREE.PointLight(0xFF0000, 1, 2);
      rearLightEmission2.position.set(-0.40, 0.125, -0.15);
      robotGroup.add(rearLightEmission2);

      // Add wheels
      const wheelGeometry = new THREE.CylinderGeometry(0.0825, 0.0825, 0.05, 16);
      const wheelMaterial = new THREE.MeshPhongMaterial({color: 0x333333});
      
      // Front-left wheel
      const wheelFL = new THREE.Mesh(wheelGeometry, wheelMaterial);
      wheelFL.rotation.x = Math.PI / 2;
      wheelFL.position.set(0.24, 0.08, 0.2);
      wheelFL.castShadow = true;
      robotGroup.add(wheelFL);
      
      // Front-right wheel
      const wheelFR = new THREE.Mesh(wheelGeometry, wheelMaterial);
      wheelFR.rotation.x = Math.PI / 2;
      wheelFR.position.set(0.24, 0.08, -0.2);
      wheelFR.castShadow = true;
      robotGroup.add(wheelFR);
      
      // Rear-left wheel
      const wheelRL = new THREE.Mesh(wheelGeometry, wheelMaterial);
      wheelRL.rotation.x = Math.PI / 2;
      wheelRL.position.set(-0.24, 0.08, 0.2);
      wheelRL.castShadow = true;
      robotGroup.add(wheelRL);
      
      // Rear-right wheel
      const wheelRR = new THREE.Mesh(wheelGeometry, wheelMaterial);
      wheelRR.rotation.x = Math.PI / 2;
      wheelRR.position.set(-0.24, 0.08, -0.2);
      wheelRR.castShadow = true;
      robotGroup.add(wheelRR);

     // Add LIDAR sensor on top of the robot
      const lidarGeometry = new THREE.CylinderGeometry(0.06, 0.06, 0.04, 16);
      const lidarMaterial = new THREE.MeshPhongMaterial({color: 0x333333});
      const lidar = new THREE.Mesh(lidarGeometry, lidarMaterial);
      lidar.position.set(0, 0.26, 0);
      robotGroup.add(lidar);

      // Position the robot
      robotGroup.position.set(0, 0, 0);
      
      // Start animation loop
      animate();
      
      // Handle window resize
      window.addEventListener('resize', onWindowResize);
    }

    function onWindowResize() {
      camera.aspect = (window.innerWidth - 300) / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth - 300, window.innerHeight);
    }

    function animate(){
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }

    function connectROS(){
      ros = new ROSLIB.Ros({ url: 'ws://192.168.2.7:9090' });

      ros.on('connection', ()=>{
        console.log('Connected to ROS');
        updateROSStatus('Connected to ROS - Ready', 'connected');
        
        // Subscribe to laser
        subscribeTo('/scan','sensor_msgs/LaserScan',processLaserData);

        // Subscribe to odometry
        subscribeTo('/hoverboard_base_controller/odom', 'nav_msgs/Odometry', processOdometry);
        
        // Subscribe to map topics
        subscribeTo('/map_metadata','nav_msgs/MapMetaData',processMapMetadata);
        subscribeTo('/map','nav_msgs/OccupancyGrid',processMapData);
        subscribeTo('/map_updates','map_msgs/OccupancyGridUpdate',processMapUpdate);

        // Setup cmd_vel publisher
        cmdVelTopic = new ROSLIB.Topic({
          ros: ros,
          name: '/cmd_vel',
          messageType: 'geometry_msgs/Twist'
        });
        
        console.log('cmd_vel topic setup complete');
      });
      
      ros.on('error', err=>{
        console.error('Error',err);
        updateROSStatus('ROS Error: ' + err, 'error');
      });
      
      ros.on('close', ()=>{
        console.log('Closed');
        updateROSStatus('ROS Connection Closed', 'disconnected');
      });
    }

    function updateROSStatus(message, status) {
      const statusElement = document.getElementById('rosStatusText');
      const indicator = document.getElementById('rosStatusIndicator');
      
      statusElement.textContent = message;
      
      // Update indicator color based on status
      if (status === 'connected') {
        indicator.style.background = '#4caf50';
      } else if (status === 'error') {
        indicator.style.background = '#f44336';
      } else {
        indicator.style.background = '#ff9800';
      }
    }

    function processOdometry(msg) {
      const pose = msg.pose.pose;
      
      currentRobotPose.position.x = pose.position.x;
      currentRobotPose.position.y = pose.position.y;
      currentRobotPose.position.z = pose.position.z;
      currentRobotPose.orientation = pose.orientation;
      
      // Convert quaternion to yaw (rotation around Y-axis)
      const qx = pose.orientation.x;
      const qy = pose.orientation.y;
      const qz = pose.orientation.z;
      const qw = pose.orientation.w;
      
      // Calculate yaw from quaternion
      const siny_cosp = 2 * (qw * qz + qx * qy);
      const cosy_cosp = 1 - 2 * (qy * qy + qz * qz);
      currentRobotPose.yaw = Math.atan2(siny_cosp, cosy_cosp);
      
      // Update the entire robot group position and rotation
      // Rotate coordinate system: ROS X (forward) -> Three.js Z (forward)
      robotGroup.position.set(
        pose.position.x,  // ROS Y (left) -> Three.js X (right, negative to match)
        0.02,              // Keep robot slightly above ground
        -pose.position.y    // ROS X (forward) -> Three.js Z (forward)
      );
      
      robotGroup.rotation.y = currentRobotPose.yaw;
      
      // Update status display
      updateROSStatus(
        `Robot: x=${pose.position.x.toFixed(2)}, y=${pose.position.y.toFixed(2)}, yaw=${(currentRobotPose.yaw * 180/Math.PI).toFixed(1)}°`,
        'connected'
      );
    }

    // --- LASER ---
    function processLaserData(msg){
      // Check if we already have a laser mesh and remove it
      if (laserPointsMesh) {
        scene.remove(laserPointsMesh);
      }

      const geom = new THREE.BufferGeometry();
      const positions = [];
      const angleMin = msg.angle_min;
      const angleInc = msg.angle_increment;
      
      for(let i = 0; i < msg.ranges.length; i++){
        const r = msg.ranges[i];
        if(!isFinite(r) || r > 30) continue;
        
        const angle = angleMin + i * angleInc;
        const x = r * Math.cos(angle);
        const z = r * Math.sin(angle);
        
        // Transform laser points to match robot position and orientation
        positions.push(
          currentRobotPose.position.x + x * Math.cos(currentRobotPose.yaw) - z * Math.sin(currentRobotPose.yaw),
          0.2, // Slightly above ground
          currentRobotPose.position.z - (x * Math.sin(currentRobotPose.yaw) + z * Math.cos(currentRobotPose.yaw))
        );
      }
      
      if (positions.length > 0) {
        geom.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        const mat = new THREE.PointsMaterial({color: 0x9c27b0, size: 0.07});
        laserPointsMesh = new THREE.Points(geom, mat);
        scene.add(laserPointsMesh);
        console.log('Laser points updated', positions.length/3);
      }
    }

// --- MAP FUNCTIONS  ---
function processMapMetadata(msg){
  mapOrigin.x = msg.origin.position.x;
  mapOrigin.y = msg.origin.position.y;
  mapResolution = msg.resolution;
  document.getElementById('mapResolution').textContent = `Resolution: ${mapResolution.toFixed(3)} m/cell`;
  console.log('Map metadata', mapOrigin, mapResolution);
}

function processMapData(msg){
  console.log('Full map received', msg.info.width, msg.info.height);
  document.getElementById('mapDimensions').textContent = `Dimensions: ${msg.info.width} x ${msg.info.height}`;
  document.getElementById('mapLastUpdate').textContent = `Last Update: ${new Date().toLocaleTimeString()}`;
  
  if (showMap) {
    create3DMap(msg.info.width, msg.info.height, msg.data);
  }
}

function create3DMap(width, height, data){
  // Remove existing map if present
  if (mapPlane) {
    scene.remove(mapPlane);
  }

  // Create canvas for map texture
  mapCanvas = document.createElement('canvas');
  mapCanvas.width = width;
  mapCanvas.height = height;
  mapCtx = mapCanvas.getContext('2d');

  // Create image data from occupancy grid
  const img = mapCtx.createImageData(width, height);
  for(let i = 0; i < data.length; i++){
    const v = data[i];
    // Color coding: gray for unknown, green for free, red for occupied
    let c = (v < 0) ? [85, 85, 85] : (v < 50 ? [76, 175, 80] : [244, 67, 54]);
    img.data[i*4] = c[0];
    img.data[i*4+1] = c[1];
    img.data[i*4+2] = c[2];
    img.data[i*4+3] = 255;
  }
  mapCtx.putImageData(img, 0, 0);

  // Create texture from canvas
  mapTexture = new THREE.CanvasTexture(mapCanvas);
  mapTexture.flipY = false; // Important for correct orientation
  mapMaterial = new THREE.MeshBasicMaterial({
    map: mapTexture, 
    side: THREE.DoubleSide,
    transparent: true,
    opacity: 0.8
  });

  // Calculate map dimensions in meters
  const mapWidthMeters = width * mapResolution;
  const mapHeightMeters = height * mapResolution;

  // Create plane for the map with correct positioning
  const geom = new THREE.PlaneGeometry(mapWidthMeters, mapHeightMeters);
  mapPlane = new THREE.Mesh(geom, mapMaterial);
  mapPlane.rotation.x = -Math.PI/2; // Rotate to lay flat on ground
  
  // Position the map correctly based on origin and dimensions
  mapPlane.position.set(
    mapOrigin.x + mapWidthMeters / 2, 
    0.01, // Slightly above ground to avoid z-fighting
    0.0
  );
  
  scene.add(mapPlane);
  
  console.log("3D map created successfully with", width * height, "cells");
  console.log("Map dimensions in meters:", mapWidthMeters.toFixed(2), "x", mapHeightMeters.toFixed(2));
  console.log("Map positioned at:", mapPlane.position.x.toFixed(3), mapPlane.position.z.toFixed(3));
  console.log("Map origin was:", mapOrigin.x.toFixed(3), mapOrigin.y.toFixed(3));
}

    function processMapUpdate(msg){
      if (!mapCtx || !showMap) return;
      
      const {x, y, width, height, data} = msg;
      const img = mapCtx.getImageData(x, y, width, height);
      
      for(let j = 0; j < height; j++){
        for(let i = 0; i < width; i++){
          const idx = (j * width + i) * 4;
          const v = data[j * width + i];
          let c = (v < 0) ? [85, 85, 85] : (v < 50 ? [76, 175, 80] : [244, 67, 54]);
          img.data[idx] = c[0];
          img.data[idx+1] = c[1];
          img.data[idx+2] = c[2];
          img.data[idx+3] = 255;
        }
      }
      
      mapCtx.putImageData(img, x, y);
      if (mapTexture) mapTexture.needsUpdate = true;
      
      document.getElementById('mapLastUpdate').textContent = `Last Update: ${new Date().toLocaleTimeString()}`;
      console.log(`Map patch update applied at (${x},${y}) size ${width}x${height}`);
    }
    
    function toggleMapVisibility() {
      showMap = !showMap;
      
      if (showMap) {
        document.getElementById('toggleMap').textContent = 'Hide Map';
        // If we have map data, create the map
        // Note: This would need access to the last received map data
      } else {
        // Hide the map
        if (mapPlane) {
          scene.remove(mapPlane);
          mapPlane = null;
        }
        document.getElementById('toggleMap').textContent = 'Show Map';
      }
    }
    
    function clearMap() {
      if (mapPlane) {
        scene.remove(mapPlane);
        mapPlane = null;
      }
      showMap = false;
      document.getElementById('toggleMap').textContent = 'Show Map';
    }

    function subscribeTo(name, type, cb){
      const topic = new ROSLIB.Topic({ ros, name, messageType:type });
      topic.subscribe(cb);
      console.log(`Subscribed to ${name}`);
    }

    // --- TELEOP ---
    function sendCmdVel(lx, az){
      if (!cmdVelTopic) {
        console.error('cmd_vel topic not initialized');
        return;
      }
      
      const twist = new ROSLIB.Message({
        linear: {x:lx, y:0, z:0},
        angular: {x:0, y:0, z:az}
      });
      
      console.log(`Sending cmd_vel: linear.x=${lx}, angular.z=${az}`);
      cmdVelTopic.publish(twist);
    }

    function move(forward, turn){
      const linScale = parseFloat(document.getElementById('linSpeed').value);
      const angScale = parseFloat(document.getElementById('angSpeed').value);
      const linearX = forward * linScale;
      const angularZ = turn * angScale;
      
      console.log(`Move called: forward=${forward}, turn=${turn}, linearX=${linearX}, angularZ=${angularZ}`);
      sendCmdVel(linearX, angularZ);
    }

    function setupEventListeners() {
      // Light toggles
      document.getElementById('frontLights').addEventListener('change', (e) => {
        const isOn = e.target.checked;
        frontLightEmission1.intensity = isOn ? 1 : 0;
        frontLightEmission2.intensity = isOn ? 1 : 0;
      });
      
      document.getElementById('rearLights').addEventListener('change', (e) => {
        const isOn = e.target.checked;
        rearLightEmission1.intensity = isOn ? 1 : 0;
        rearLightEmission2.intensity = isOn ? 1 : 0;
      });
      
      // Map controls
      document.getElementById('toggleMap').addEventListener('click', toggleMapVisibility);
      document.getElementById('clearMap').addEventListener('click', clearMap);
    }
  </script>
</body>
</html>